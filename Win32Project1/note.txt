注意传入shader里面的矩阵的行列式，代码：
glUniformMatrix4fv(m_tech->getUniformLocation("MVPMatrix"), 1, GL_TRUE, (const float*)m_MVPMt4.m);
GL_TRUE参数。
外部程序软处理的时候，注意MVPMatrix的行列式，是否需要转置一下。






在NDC坐标系中，近裁剪面的z值为-1，远裁剪面的z值为1



数学之美，就在于能够找到其他的方法来代替这种显而易见的方式，从而将问题简化到一定的程度。这种简化的过程，不需要在代码中实现，只需要我们事先根据条件，然后在草稿纸上计算出最后的结论，我们只需要在我们的代码中直接使用最终得到的结论即可。
http://blog.csdn.net/i_dovelemon/article/details/38332499





线性变换：
1.直线还是直线
2.线段之间的比例不变
3.原点不变
旋转，推移，缩放，所以线性变换用2*2或者3*3矩阵乘法来计算，没有齐次坐标无法表示平移。
仿射变换就是在线性变换的基础上加了平移，是的原点位置可以改变，矩阵上多加了一维。

--------------------------------------------------------------------------------------------------------------
点point，线line，面panel：
点积(标量c=w*v)：
点积就是a向量在b向量上的投影的长度值。
公式：
投影长度=|w|*cos(a)=|w|*(w*v/(|w|*|v|))
当wv归一化(normalize)之后 单位向量(模为1)，投影长度=w*v，为夹角的弧度值。
两个向量的的夹角，>0为锐角，反之为钝角。


叉积(向量c=a^b)：
垂直于两个向量所组成的panel，
方向的判定：右手展开，四指与向量a的方向一样，然后，弯曲四指后与向量b的方向一样，这时的大母指所指的方向就是向量c的方向。
即a转向b的方向是逆时针时c的方向为上，反之为下。


射线：
就是由一个原点，一个方向组成，这条射线由原点朝着射线方向移动t个单位，
所以公式由original+t*dir组成, t*dir就是射线发射出去的线段

--------------------------------------------------------------------------------------------------------------